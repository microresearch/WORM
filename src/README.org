* ERD?WORM dirty speech synth

32k sample rate

* TODO

- sort out memory allocations
- basics of read/write head and speech integration
- tests for each speech function/mode
- vocoder and how we deal with buffers?
- integrate/test/new knob allocations

* knobs

#define MODE 3 // for pcb=2
#define SELX 0 //3
#define SPEED 2 //0
#define END 4 //4
#define SELY 1 //1

* modes so far imagined - say 32 total!

0/klatt - single phoneme
0.1/klatt - list of phonemes
0.2/klatt - worm away starting on phoneme base (earth worm) - or trigger that base
1/vosim 
2/x-y filter 
3/LPC 
4/vocoder+different channel
swops/arrangements 
x/klatt screwed/bent 
x/other filter 
x/raw wormed klatt
x/wormed vosim 
x/wormed x/y filter

+ variations say on vosim etc...
+ other speech synths

++ vocoder options with different sources - square wave, white noise etc.

all modes doubled by worm - worm from base through parameter
constraints for each. trigger resets to base. thus double for each mode more or less


* progress

** 4/11/2015

- stripped code and it compiles

** 9-10/11/2015

- knobs left/right from top (pcb and lach=test) = 0/mode-(2..3)
1/selX.egX-(3..2) 2/speed-(0..4) 3/end-(4..1)
4/trigthresh/vocoderfreq/othersel.eg/selY-(1..0) SEE audio.h

- input=threshold/vocoder_voice

- question of scheduling: examples? trigger_to_sync needs to be in
  reading in code (and trigger say new phoneme), braids operates with blocks-sync_buffer and render_buffer?

what is framesize for audio=32 x u16//

- and how frames work for speech/klatt? - frame is 256 samples = 512 bytes

frame=XmS of audio output p so we have ms at 32K = 

*** - list modes and examples: 

0/klatt 1/vosim 2/x-y filter 3/LPC 4/vocoder+different channel
swops/arrangements x/klatt screwed x/other filter x/raw wormed klatt
x/wormed vosim x/wormed x/y filter

+++ vocoder options with different sources - square wave, white noise etc.

all modes doubled by worm - worm through parameters for each

- what effects we implement in DI: mdavoc, pvvoc

- what are other speech synth/modes??? LIST from earthvoice2:

raw//basic klatt parameters?

1-
robo: arduino = 8 bit
TTS: same as robo above

2-
sam: It is an adaption to C of the speech software SAM (Software Automatic Mouth) for the Commodore C64 - 8 bit and messy
tinySAM.c: small SAM above - 8 bit
SAMarduino: arduino of tinySAM above - 8 bit

3-
Talkie-LPCcode: :LPC - encode new words with QBoxPro/windows... TI99

4-
*Tiny Speech Synth: C code - TinySynth.h 16 bit*

5-
*/afs/athena/astaff/project/phones/Speak emulates SPO256*

at: [[file:~/Downloads/stuff.mit.edu/afs/athena/astaff/project/phones/Speak/speak.c]]

- need convert samples to arrays in flash - clip header. format is: mu-law 8 bit 

sox AA --bits 8 --channels 1 --encoding unsigned-integer --rate 8000 file.raw

but as array// short code - open filename, output array_name=blah,,,,

6-

other: cantarino - /root/projects/ERD_modules/older/euro-modules/Talko/Software/Canto

7-

braids(=rendervowel and rendervowelfof)

8-

Formlet as filter in SC: [[file:~/SuperCollider-Source/server/plugins/FilterUGens.cpp::void%20Formlet_next_1(Formlet*%20unit,%20int%20inNumSamples)][file:~/SuperCollider-Source/server/plugins/FilterUGens.cpp::void Formlet_next_1(Formlet* unit, int inNumSamples)]]

9-

https://batchloaf.wordpress.com/2012/09/21/ugly-speech-synthesis-in-c/ =

csound fof= http://www.csounds.com/manual/html/fof.html - ugens7.c

[LPC: [[file:~/sc3-plugins/source/NCAnalysisUGens/LPCAnalysis.cpp::*%20LPCAnalysis.cpp][file:~/sc3-plugins/source/NCAnalysisUGens/LPCAnalysis.cpp::* LPCAnalysis.cpp]]

and LPCsynth]

[1. phase vocoder/FFT - our old pitchscale.c??? 

JoshUGens/sc/classes/Vocoder.sc

SCcode=PV_SpectralMap, borsboom, snokoder]

- 2. 16 channel bandpass/formant/vocoder: ladspa DONE?in effect.c= vocoder.c //pv is not fully functional

or vst-mda version: mdaVocoder.cpp TEST/TRY mdavoc=input and mdavocoder? see effect.c/mda...

///

X/Y//simple formant filtering (above)//generic filter conv. bbandpass, biquad, bandpass in effect.c and setup of 

runform in simforstacksansmem 

and biquad in doformantfilter

- formant frequency/vowel table (vowels announced from buf16 as
  text->vowels,Q,length of vowel?)
  ????===arm_biquad_cascade_df1_init_f32??? in main.c in DI

formant ugens: http://gurzil.livejournal.com/15375.html

SC synthdef for vowels with BBandPass : http://sccode.org/1-4Vk:

** xxx

*This week to have basic scheduling for klatt and knob allocations, memory. Also kind of template for other generators*

*template should be triggerable version and free-running version - mark each as such!*

** 11/11

- can we have say 128k contig memory? can use say 120k but need to assign memory to ccm if need more than 8k for other tasks

but not enuff memory in that case and can't program it (look for
larger arrays?) - set now to 32768 so can do loggy as is and can
always change loggy

will need to look into stm32_flash.ld for ccm definition - TESTed okayyyy....

eg. u16 sin_data[256] __attribute__ ((section (".ccmdata")));  // sine LUT Array

FIXED 12/11

- stmlib => fft etc.

so we putr eg.  int16_t pWavBuffer[3840] __attribute__ ((section (".ccmdata")));

// testing now basics - why is so quiet?

// parwave is in nsynth - this handles the klatt frames

*** final 11/11 notes

- need to break down phoneme frames and/or move phoneme generation out
  of audio.c interrupt as is too long/slow - also as if we re-trigger
  fast then is only start of phoneme we hear...

  moved out of interrupt which means we have 32 samples/trigger always issue (so is 32 samples max slowed)- seems okay now

- to test all phonemes... also still question of volume to solve - HW on test board?

[- enter_phonemes() in phtoelm is executed only once? and can we bypass
  this for individual phonemes? or is case of phoneme and last one?]

/// all of rsynth is about transitions between phonemes and we just
have one - so simplify or fake this/make longer phoneme cases. see holmes.c

/BUT/and our list of phonemes is the lookup list - to figure out what we
need to send to holmes for 2nd part and simplify holmes for 1 phoneme 12/11
or do X/Y of 2 phonemes - but what of trigger? or trigger on max!

either way simplify to numericals an no string stuff/memory 

- klatt/rsynth on pc verbose to check all...-> see Downloads/rsynth-2.0 (also updated rsynth version?)

- TODO: raw klatt with certain start positions and worm off from these within parameter bounds for each

- TODO: generate and test square for vocoder

** 12/11

- fixed stm32_flash.ld CCM mistake

- retest trigger - fixed as VOLATILE

- break down rsynth - problem is if we even have 1 phoneme + stress then is ended!

so we need to open up holmes.c so keeps running and writes directly
into audio_buffer and deals with trigger/phoneme selection (is always
one phoneme behind? - but not great idea as we can't look ahead?

how do we get stress and dur from phoneme?

this is dur in phone_to_elm

if (!(p->feat & vwl))
stress = 0;
t += phone_append(elm,StressDur(p,stress));
(int) (StressDur(p, stress, islong)));
#define StressDur(e,s,l) ((e->ud + (e->du - e->ud) * s / 3)*speed)

for each one in elements.def

next bit is stress?

stress is either 0,1,2 or 3

so we have phoneme_num//dur//stress and 1/6/0 seems to be ending (twice??)

- also need to get rid of pwavebuffer and write straight IN

- 32k=64k=128 frames

- can enlarge audio buffer now we have fixed ccm so could be 60k =
  120k = say 200 frames audio.h = 58870 with log_gen.py calculating
  end

*if we enlarge then re-do loggy for this size*

*69 is number of phonetic elements - stress or no stress = 69x4=272 - close to 255???* leave stress as 0 for now

*** notes

- how does CV select phoneme - like how often do we sample CV to give
phoneme? do we have phoneme list which we run through into buffer and
shift out or? based on speed? as have it trigger is the one

- working on run_holmes which is constant running and trigger-able -
  test this and then figure out how to update list... 

- clip in nsynth *4.0f for volume increase ADDED - VOLUME fixed

- still scheduling question - say for run_holmes so doesn't just cycle
  over itself... wait until playhead passes how?

// and run_holmes seem start with phrase fine and run DOWN - if we run continuous then will tail off!

- run_holmes as 2nd mode (MODE=1)

- how does run_holmes know how much to fill buffer? - overfill?/average - silence is ok

- triggering and scheduling is main issue// add to end of phoneme list and shift left or just re-write (more modes?)re-write!-TODO

- mode1-run_holmes - use trigger to freeze any changes to phoneme list as extra mode-TODO

*TODO: proof tests on VOSIM(sc/braids/csound/sc-formlets),XY(bbandpass,doformantfilter, biquad), vocoder(ladspa?/mdavoc=input and
mdavocoder?/mdatalkbox/pv_vocoder=justFFTsofar), LPC(talkie and SC), canto etc.*

*check all effect.c, other DI files*

*TODO: changes suggested above//how to test-simulate triggerCV also*

** 13/11

Note that trigger will always be slow as we _just_ process the buffer in audio.c - not LIVE...

Working on *VOSIM_SC* versionings - trigin could also be seperate timer/counter - controlled by? - Impulse.ar - LFUGens.cpp

- need to organise parameters for VOSIM as so far we don't do decay

- writepos always given and returned so we can sync

- single VOSIM - until it ends, how is triggered? - but this is just SC triggering

*** notes

- do impulse.ar in vosim, but also like random triger variant that we have

VOSIM_SC:

*ar (trig: 0.1, freq: 400, nCycles: 1, decay: 0.9, mul: 1, add: 0)
Arguments:
trig [ar kr] starts a vosim pulse when a transition from non-positive to positive occurs and no other vosim is still going. audio rate input will produce sample accurate triggering.
freq [ar kr] the frequency of the squared sinewave.
nCycles	- the number of squared sinewaves to use in one vosim pulse. nCycles gets checked when VOSIM receives a trigger.
decay - the decay factor.

eg. http://doc.sccode.org/Classes/VOSIM.html

*do away with END and use as 3rd parameter - in some cases. eg. in
phonemes do we even use 2nd par?*

*TODO: rationalise phonemes so there are 64 or is probability table - also order in which they are arranged could follow probability of transitions...*

** 15/11

Different voices:

Note in Klatt: The facility to use a sampled natural excitation
waveform has been implemented. Naturalness of the resulting synthetic
speech can be greatly improved by using the glottal excitation
waveform from a natural speaker, especially if it is the speaker on
whose voice the synthesis is actually based. This may be obtained
indirectly by inverse-filtering a vowel.

HOW? - this function is in different klatt: [[file:~/Downloads/www.laps.ufpa.br/aldebaro/classes/04procvoz1sem/Klatts/Klatt-C-Windows-F0flutter/Src/parwave.cpp::/*]]

but we could use incoming samples as this? inverse filtering?

Take a recorded vowel and locate the overall peaks and valleys in the spectrum (the formants) by using an LPC (linear predictive coding) algorithm

These peaks and valleys, at least theoretically, should represent the resonances in the mouth caused by a given tongue shape

Use this information to reconstruct the voicing signal (the source) without those peaks and valleys

This is accomplished by inverse-filtering the signal with the LPC, raising the parts of the spectrum which the LPC says are low, and lowering the parts which the LPC says are high. The end result, ideally, will be the source signal as if the person had no vocal tract at all.

http://doc.sccode.org/Classes/LPCAnalyzer.html

but inverse filter?

https://github.com/freedv/codec2/blob/master/src/lpc.c

[[file:~/projects/ERD_modules/worm/lpc.c::FILE........:%20lpc.c][file:~/projects/ERD_modules/worm/lpc.c::FILE........: lpc.c]]

Klatt:Flutter?

also NATURAL and IMPULSIVE in def_pars.c to test as is always now set to impulsive

now klatt_params - see also http://linguistics.berkeley.edu/plab/guestwiki/index.php?title=Klatt_Synthesizer_Parameters

*** TODO

- x/y bandpass - which ones in DI? ABOVE

- vocoder/s - see ABOVE

- alt speech synths listed ABOVE

- klatt LPC stuff

- new scheduling template from notebook

/////

- raw klatt and other wormings....

- phoneme probabilities and all TODO above!
