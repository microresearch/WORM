
#include "global.h"


// Random number seed
uint8_t seed0;
uint8_t seed1;
uint8_t seed2;

char BUFFphonemes[128];   
char BUFFmodifier[128];   // must be same size as 'phonemes'
char g_text[64];

uint8_t default_pitch = 6;


//#ifdef _AVR_
   // Define routines to log to the UART
   


// Lookup user specified pitch changes
static rom uint8_t PitchesP[]  = { 1, 2, 4, 6, 8, 10, 13, 16 };

/**
*
*  Find the single character 'token' in 'vocab'
*  and append its phonemes to dest[x]
*
*  Return new 'x'
*/

int copyToken(char token,char * dest, int x, VOCAB_T* vocab){
   int ph;
   char* src;

   for(ph = 0; ph < numVocab; ph++){
      char *txt = (char *)pgm_read_word(&vocab[ph].txt);
      if(pgm_read_byte(&txt[0]) == token && pgm_read_byte(&txt[1])==0){

         src = pgm_read_word(&vocab[ph].phoneme);
         while(pgm_read_byte(src)!=0){
            dest[x++] = pgm_read_byte(src);
            src++;
         }
         break;
      }
   }

   return x;
}

uint8_t whitespace(char c){
   return (c==0 || c==' ' || c==',' || c=='.' || c=='?' || c=='\'' 
      || c=='!' || c==':' || c=='/') ? 1 : 0;
}

/**
*  Enter:
*  src => English text in upper case
*  vocab => VOCAB array
*  dest => address to return result
*  return 1 if ok, or 0 if error
*/
int textToPhonemes(char *src, VOCAB_T *vocab, char *dest){
   int outIndex = 0;// Current offset into dest
   int inIndex = -1; // Starts at -1 so that a leading space is assumed

   while(inIndex==-1 || src[inIndex]!= 0){   // until end of text
      int maxMatch=0;   // Max chars matched on input text
      int numOut=0;   // Number of characters copied to output stream for the best match
      int ph;
      bool endsInWhiteSpace=FALSE;
      int maxWildcardPos = 0;

      // Get next phoneme, P2
      for(ph = 0; ph < numVocab; ph++){
         int y,x;
         char wildcard=0; // modifier
         int wildcardInPos=0;
         bool hasWhiteSpace=FALSE;
         char* text = (char*)pgm_read_word(&vocab[ph].txt); 
         char* phon = (char*)pgm_read_word(&vocab[ph].phoneme); 



         for(y=0;;y++){

            char nextVocabChar = pgm_read_byte(&text[y]);
            //char nextCharIn = (y + inIndex==-1) ? ' ' : src[y + inIndex];
            
            char nextCharIn;
            
            if(y + inIndex==-1) 
               nextCharIn = ' ';
            else
               nextCharIn = src[y + inIndex];
            
            if(nextCharIn>='a' && nextCharIn<='z'){
               nextCharIn = nextCharIn - 'a' + 'A';
            }
   
            if(nextVocabChar=='#' && nextCharIn >= 'A' && nextCharIn <= 'Z'){
               wildcard = nextCharIn; // The character equivalent to the '#'
               wildcardInPos=y;
               continue;
            }

            if(nextVocabChar=='_'){
               // try to match against a white space
               hasWhiteSpace=TRUE;
               if(whitespace(nextCharIn)){
                  continue;
               }
               y--;
               break;
            }

            // check for end of either string
            if(nextVocabChar==0 || nextCharIn==0){
               break;
            }

            if(nextVocabChar != nextCharIn){
               break;
            }
         }

         // See if its the longest complete match so far
         if(y<=maxMatch || pgm_read_byte(&text[y])!=0){
            continue;
         }


         // This is the longest complete match
         maxMatch = y;
         maxWildcardPos = 0;
         x = outIndex; // offset into phoneme return data

         // Copy the matching phrase changing any '#' to the phoneme for the wildcard
         for(y=0;;y++){
            char c = pgm_read_byte(&phon[y]);
            if(c==0)
               break;
            if(c=='#'){
               if(pgm_read_byte(&phon[y+1])==0){
                  // replacement ends in wildcard
                  maxWildcardPos = wildcardInPos;
               }else{
                  x = copyToken(wildcard,dest,x, vocab); // Copy the phonemes for the wildcard character
               }
            }else{
               dest[x++] = c;
            }
         }
         dest[x]=0;
         endsInWhiteSpace = hasWhiteSpace;

         // 14
         numOut = x - outIndex;   // The number of bytes added

      }// check next phoneme
      // 15 - end of vocab table

      //16
      if(endsInWhiteSpace==TRUE){
         maxMatch--;
      }

      //17
      if(maxMatch==0){
         //loggerP("Mistake in SAY, no token for "); 
         sprintf(logtxt,"Mistake in SAY, no token for %s", src[inIndex]); doslog(logtxt);
         //logger(&src[inIndex]);
         return 0;
      }

      //20
      outIndex += numOut;
      if(outIndex > 256-16){
         sprintf(logtxt,"Mistake in SAY, text too long "); doslog(logtxt);
         return 0;
      }

      //21 
      
      //inIndex += (maxWildcardPos>0) ? maxWildcardPos : maxMatch;
      if(maxWildCardPos>0)
         inIndex += maxWildCardPos;
      else
         inIndex += maxMatch;
   }
   return 1;
}


/**
*
*   Convert phonemes to data string
*   Enter: textp = phonemes string
*   Return: phonemes = string of sound data
*         modifier = 2 bytes per sound data
*
*/
int phonemesToData(char* textp, PHONEMET_T* phoneme){

   int phonemeOut = 0; // offset into the phonemes array
   int modifierOut = 0; // offset into the modifiers array
   unsigned int L81=0; // attenuate
   unsigned int L80=16;

   while(*textp != 0){
      // P20: Get next phoneme
      bool anyMatch=FALSE;
      int longestMatch=0;
      int ph;
      int numOut=0;   // The number of bytes copied to the output for the longest match
      

      // Get next phoneme, P2
      for(ph = 0; ph<numPhoneme; ph++){
         int numChars;

         // Locate start of next phoneme 
         char* ph_text = (char*)pgm_read_word(&phoneme[ph].txt);

         
         // Set 'numChars' to the number of characters
         // that we match against this phoneme
         for(numChars=0;textp[numChars]!=0 ;numChars++){

            // get next input character and make lower case
            char nextChar = textp[numChars];
            if(nextChar>='A' && nextChar<='Z'){
               nextChar = nextChar - 'A' + 'a';
            }

            if(nextChar!=pgm_read_byte(&ph_text[numChars])){
               break;
            }
         }

         // if not the longest match so far then ignore
         if(numChars <= longestMatch) continue;

         if(pgm_read_byte(&ph_text[numChars])!=0){
            // partial phoneme match
            continue;

         }

         // P7: we have matched the whole phoneme
         longestMatch = numChars;

         // Copy phoneme data to 'phonemes'
         {
            char* ph_ph = (char*)pgm_read_word(&phoneme[ph].phoneme);
            for(numOut=0; pgm_read_byte(&ph_ph[numOut])!= 0; numOut++){
               BUFFphonemes[phonemeOut+numOut] = pgm_read_byte(&ph_ph[numOut]);
            }
         }
          L81 = pgm_read_byte(&phoneme[ph].attenuate)+'0';
         anyMatch=TRUE; // phoneme match found

         BUFFmodifier[modifierOut]=-1;
         BUFFmodifier[modifierOut+1]=0;

         // Get char from text after the phoneme and test if it is a numeric
         if(textp[longestMatch]>='0' && textp[longestMatch]<='9'){
            // Pitch change requested
            BUFFmodifier[modifierOut] = pgm_read_byte(&PitchesP[textp[longestMatch]-'1'] );
            BUFFmodifier[modifierOut+1] = L81;
            longestMatch++;
         }

         // P10
         if(L81!='0' && L81 != L80 && BUFFmodifier[modifierOut]>=0){
            BUFFmodifier[modifierOut - 2] = BUFFmodifier[modifierOut];
            BUFFmodifier[modifierOut - 1] = '0';
            continue;
         } else {

            // P11
            if( (textp[longestMatch-1] ) == 0x20){
               // end of input string or a space
               //BUFFmodifier[modifierOut] = (modifierOut==0) ? 16 : BUFFmodifier[modifierOut-2];
               if(modifierOut == 0)
                  BUFFmodifier[modifierOut] = 16;
               else
                  BUFFmodifier[modifierOut] = BUFFModifier[modifierOut-2];
            }
         }

      } // next phoneme

      // p13
      L80 = L81;
      if(longestMatch==0 && anyMatch==FALSE){
         //loggerP(PSTR("Mistake in speech at "));
         sprintf(logtxt,"Mistake in speech at %s", textp); doslog(logtxt);
         //logger(textp);
         return 0;
      }

      // Move over the bytes we have copied to the output
      phonemeOut += numOut;

      if(phonemeOut > sizeof(buffphonemes)-16){
         printf(logtxt,"Mistake Text too long");
         return 0;
      }

      // P16

      // Copy the modifier setting to each sound data element for this phoneme
      if(numOut > 2){
         int count;
         for(count=0; count != numOut; count+=2){
            buffmodifier[modifierOut + count + 2] = buffmodifier[modifierOut + count];
            buffmodifier[modifierOut + count + 3] = 0;
         }
      }
      modifierOut += numOut;

      //p21
      textp += longestMatch;
   }

   buffphonemes[phonemeOut++]='z';
   buffphonemes[phonemeOut++]='z';
   buffphonemes[phonemeOut++]='z';
   buffphonemes[phonemeOut++]='z';
   
   while(phonemeOut < sizeof(buffphonemes)){
      buffphonemes[phonemeOut++]=0;
   }

   while(modifierOut < sizeof(buffmodifier)){
      buffmodifier[modifierOut++]=-1;
      buffmodifier[modifierOut++]=0;
   }

   return 1; 
}




/*
*   A delay loop that doesn't change with different optimisation settings
*/

void pause(uint8_t delay){
   uint8_t r;
   for(r=0; r<6; r++){
      //loop(delay);
      delay_us(delay);
   }

}

#define delay(x) delay_ms(x)

/*
   Generate a random number
*/
uint8_t random(void){
   uint8_t tmp = (seed0 & 0x48) + 0x38;
   seed0<<=1;
   if(seed1 & 0x80){
      seed0++;
   }
   seed1<<=1;
   if(seed2 & 0x80){
      seed1++;
   }
   seed2<<=1;
   if(tmp & 0x40){
      seed2++;
   }
   return seed0;
}




void soundOff(void){

   
   setup_ccp1(CCP_OFF);
   set_pwm1_duty(0);

}

void soundOn(void){

   setup_timer_2(T2_DIV_BY_1,0xff,1);      //22.8 us overflow, 22.8 us interrupt


   setup_ccp1(CCP_PWM|CCP_SHUTDOWN_AC_L|CCP_SHUTDOWN_BD_L);
   


   seed0=0xCEu;
   seed1=7;
   seed2=0xCFu;

}

// Logarithmic scale
//static rom int16_t Volume[8] = {0,PWM_TOP * 0.01,PWM_TOP * 0.02,PWM_TOP * 0.03,PWM_TOP * 0.06,PWM_TOP * 0.12,PWM_TOP * 0.25,PWM_TOP * 0.5};

// Linear scale
static rom int16_t Volume[8] = {0,PWM_TOP * 0.07,PWM_TOP * 0.14,PWM_TOP * 0.21,PWM_TOP * 0.29,PWM_TOP * 0.36,PWM_TOP * 0.43,PWM_TOP * 0.5};
/*
static uint16_t Volume[8] = {0,
   56,
   112,
   168,
   232,
   288,
   344,
   400};
*/

//#byte FB7h
int16_t old_duty;

void sound(uint8_t b){
   b = (b & 15);

	
   // Update PWM volume 
   uint16_t duty = Volume[b>>1];     // get duty cycle   
   if(duty!=old_duty){
      old_duty=duty;
   
//      TCNT1=0;
//      OCR1B = duty;
      //set_timer2(0);
      //set_pwm1_duty((int16)duty+80);
      set_pwm1_duty((int16_t)(duty)+128);
   }
   
	
}



uint8_t playTone(uint8_t soundNum, uint8_t soundPos, char pitch1, char pitch2, uint8_t count, uint8_t volume){
   uint8_t* soundData = &SNDSMP + ((int16)(soundNum) * 0x40);
   //int8 cmd = pgm_read_byte(&soundData[soundPos % 0x40]);
   
   //sprintf(logtxt, "value: %02X @ soundnum:%u", cmd, soundnum); doslog(logtxt);
   while(count-- > 0 ){
      int8_t s;
      
      s = pgm_read_byte(&soundData[soundPos & 0x3F]);
      sound((s & volume));
      pause(pitch1);
      sound(((s>>4) & volume));
      pause(pitch2);

      soundPos++;
   }
   return soundPos & 0x3f;
}

void play(uint8_t duration, uint8_t soundNumber){
   while(duration-- != 0){
      playTone(soundNumber,random(), 7,7, 10, 15);
   }
}


void setPitch(uint8_t pitch){
   default_pitch = pitch;
}


/*
*  Speak a string of phonemes
*/
void speak(char* textp){
   uint8_t 
      phonemeIn,            // offset into text
      byte2,
      modifierIn,            // offset into stuff in modifier
      punctuationPitchDelta;   // change in pitch due to fullstop or question mark
      
   char byte1;
   char phoneme;
   SOUND_INDEX_T* soundIndex;
   uint8_t sound1Num;         // Sound data for the current phoneme
   uint8_t sound2Num;         // Sound data for the next phoneme
   uint8_t sound2Stop;         // Where the second sound should stop
   char pitch1;         // pitch for the first sound
   char pitch2;         // pitch for the second sound
   short i;
   uint8_t sound1Duration;      // the duration for sound 1
   
   if(phonemesToData(textp,s_phonemes)){
      // phonemes has list of sound bytes


      soundOn();
      
      // _630C
      byte1=0;
      punctuationPitchDelta=0;

      //Q19
      for(phonemeIn=0,modifierIn=0;buffphonemes[phonemeIn]!=0; phonemeIn+=2, modifierIn+=2){
         uint8_t  duration;   // duration from text line
         uint8_t 	SoundPos;   // offset into sound data
         uint8_t 	fadeSpeed=0;

         phoneme=buffphonemes[phonemeIn];
         if(phoneme=='z'){
            delay(15);
            continue;
         }else if(phoneme=='#'){
            continue;
         }else{

            // Collect info on sound 1
            soundIndex = &SNDINDEX[phoneme - 'A'];
            sound1Num = pgm_read_byte(&soundIndex->SoundNumber);
            byte1 = pgm_read_byte(&soundIndex->byte1);
            byte2 = pgm_read_byte(&soundIndex->byte2);

            duration = buffphonemes[phonemeIn+1] - '0';   // Get duration from the input line
            if(duration!=1){
               duration<<=1;
            }
            duration += 6;                     // scaled duration from the input line (at least 6)

            sound2Stop = 0x40>>1;


            pitch1 = buffmodifier[modifierIn];
            if(buffmodifier[modifierIn + 1]==0 || pitch1==-1){
               pitch1 = 10;
               duration -= 6;
            }else if(buffmodifier[modifierIn + 1]=='0' || duration==6){
               duration -= 6;
            }
            

            //q8
            pitch2 = buffmodifier[modifierIn+2];
            if(buffmodifier[modifierIn + 3]==0 || pitch2 == -1){
               pitch2 = 10;
            }

            //q10

            if(byte1<0){
               sound1Num = 0;
               random();
               sound2Stop=(0x40>>1)+2;


            }else{
               // is positive
               if(byte1==2){
                  // 64A4
                  // Make a white noise sound !
                  uint8_t volume;               // volume mask

                  //volume = (duration==6) ? 15 : 1;  /// volume mask
                  
                  if(duration==6)
                     volume = 15;
                  else
                     volume = 1;
                  
                  for(duration <<= 2; duration>0; duration--){
                     playTone(sound1Num,random(),8,12,20, volume);
                     // Increase the volume
                     if(++volume==16){
                        volume = 15;   // full volume from now on
                     }

                  }
                  continue;

               }else{
                  //q11
                  if(byte1 != 0){
                     delay(25);
                  }
               }
            }

         }


         // 6186
         pitch1 += default_pitch + punctuationPitchDelta;
         if(pitch1<1){
            pitch1=1;
         }

         pitch2 += default_pitch + punctuationPitchDelta;
         if(pitch2<1){
            pitch2=1;
         }

         // get next phoneme
         phoneme=buffphonemes[phonemeIn + 2];

         if(phoneme==0 || phoneme=='z'){
            if(duration==1){
               delay(60);
            }
            phoneme='a';   // change to a pause
         }else{
            // s6
            if(byte2 != 1){
               byte2 = (byte2 + pgm_read_byte(&SoundIndex[phoneme-'A'].byte2))>>1;
            }

            if(byte1 < 0 || pgm_read_byte(&SoundIndex[phoneme-'A'].byte1) != 0){
               phoneme ='a'; // change to a pause
            }
         }

         // S10
         sound2Num = pgm_read_byte(&SoundIndex[phoneme-'A'].SoundNumber);

         sound1Duration = 0x80;         // play half of sound 1
         if(sound2Num==sound1Num){
            byte2 = duration;
         }

         // S11
         if( (byte2>>1) == 0 ){
            sound1Duration = 0xff;            // play all of sound 1
         }else{
            // The fade speed between the two sounds
            fadeSpeed = (sound1Duration + (byte2>>1))/byte2;

            if(duration==1){
               sound2Stop = 0x40;   // dont play sound2
               sound1Duration = 0xff;         // play all of sound 1
               pitch1 = 12;
            }
         }

         SoundPos = 0;
         do{
            uint8_t sound1Stop = (sound1Duration>>2) & 0x3fu;
            //uint8_t sound1End = min(sound1Stop , sound1Stop);   // min(a,b) (a<b) ? a:b
            
            uint8_t sound1end;
            
            if(!(sound1Stop<sound1Stop))
               sound1end = sound2stop; 

            if( sound1Stop != 0 ){
               SoundPos = playTone(sound1Num,SoundPos,pitch1,pitch1, (uint16_t)sound1End, 15);
            }

            // s18
            if(sound2Stop != 0x40){
               SoundPos = playTone(sound2Num,SoundPos,pitch2,pitch2, (uint16_t)(sound2Stop - sound1End), 15);
            }

            //s23
            if(sound1Duration!=0xff && duration<byte2){
               // Fade sound1 out
               sound1Duration -= fadeSpeed;
               if( sound1Duration >= (uint8_t)0xC8){
                  sound1Duration=0;   // stop playing sound 1
               }
            }


            // Call any additional sound
            if(byte1==-1){
               play(3,30);   // make an 'f' sound
            }else if(byte1==-2){
               play(3,29);   // make an 's' sound
            }else if(byte1==-3){
               play(3,33);   // make a 'th' sound
            }else if(byte1==-4){
               play(3,27);   // make a 'sh' sound
            }

         }while(--duration!=0);
       

         // Scan ahead to find a '.' or a '?' as this will change the pitch
         punctuationPitchDelta=0;
         for(i=6; i>0; i--){
            char next = buffphonemes[phonemeIn + (int16)(i * 2)];
            if(next=='i'){
               // found a full stop
               punctuationPitchDelta = 6 - i; // Lower the pitch
            }else if(next=='h'){
               // found a question mark
               punctuationPitchDelta = i - 6; // Raise the pitch
            }
         }

         if(byte1 == 1){
            delay(25);
         }


      } // next phoneme

   }
   soundOff();
}

/*
*   Speak an English command line of text
*/
void say(char * original){
   int i;
   if(textToPhonemes(original, s_vocab, buffphonemes)){
#ifdef _LOG_
      sprintf(logtxt,"SAY: %s", original); doslog(logtxt);
      sprintf(logtxt,"Phones: %s", buffphonemes); doslog(logtxt);
#endif
      // copy string from phonemes to text 
      for(i = 0;buffphonemes[i]!=0;i++){
         g_text[i]=buffphonemes[i];
      }
      while(i<sizeof(g_text)){
         g_text[i++]=0;
      }

      speak(g_text);
   }
}

